using System;
using DGAC;
using hpe.basic;
using hpe.kinds;
using data.Function;
using data.IntegralCase;
using jefferson.data.Double;
using skeleton.Farm.Work.ApproximateIntegral;

namespace skeleton.impl.Farm.Work.ApproximateIntegral { 

public class IApproximateIntegralImpl<F, I, O> : BaseIApproximateIntegralImpl<F, I, O>, IApproximateIntegral<F, I, O>
where F:IFunction
where I:IIntegralCase<F>
where O:IDouble
{

public IApproximateIntegralImpl() { 

} 

public override void compute() { 
	
   output_data.Value = approximateIntegral(xinf.Value, 
                                           xsup.Value, 
                                           function.f(xinf.Value), 
                                           function.f(xsup.Value));

} // end activate method 

double approximateIntegral(double a, double b, double fa, double fb) 
{
	double  mid, fmid, larea=0.0, rarea=0.0, error = 1.0, epsilon = 1d-5;
	
    double area = approximateIntegral(a,b,fa,fb);
	
	while (error > epsilon) {
	   mid = (b + a)/2;
	   fmid = function.f(mid);
	   larea = approximateIntegral(a,mid,fa,fmid);
	   rarea = approximateIntegral(mid,b,fmid,fb);
	   
	   error = (larea + rarea)/area; 
	}
	
    return larea + rarea;
}

}

}
