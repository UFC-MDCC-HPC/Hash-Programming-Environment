<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000176a8289150e11128b302981ed5749025f17245b7b8fe4720244ba0aa74a2a2190ecf7371d21cc42bdc131fb70c85587d8336479804f1318144f9799e5a45d7627b273528381f40a83b2d94f7404cc92c72733febcfd118e879216ccad84721711c916dc9de90b0736ce37f524d3139946bd1164a2f5246d9fb5a2c43676faa2" isAbstract="false" kind="Data" name="ProblemDefinitionImpl" packagePath="impl.common.data">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="002400000480000094000000060200000024000052534131000400001100000009b97ce4f3981d78e251ff90894751a2f19e3d7fcafeadee8da1cb93890a7d9ed59b4773f575afc0782c61b877ac17cea1ab4429bfd162c1bdff0b6c7fe9d07f8e9ccdcd219b58671c77cf6cfbada633e18309cb4c2e518fedeaa6aecf435a12dc4a18c8384c15d61dfab5a2056f58c2bcf936823b8d84a8c5cc5e25827a1598" localRef="base" location="common.data.ProblemDefinition/ProblemDefinition.hpe" name="ProblemDefinition" package="common.data" version="1.0.0.0">
        <visualDescription h="30" w="50" x="328" y="280">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <parameter formFieldId="instance_type" varName="I"/>
        <parameter formFieldId="class" varName="C"/>
        <unitBounds uRef="problem">
          <visualDescription h="10" w="10" x="5" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
  </header>
  <componentInfo>
    <innerComponent hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000796ff7bbb33560060ee9951c4f8242d987089c0c50af1d3a6ab2f92466788c33bfa42e66a347c4206d81a948be78598f82f386b898f40714662cb0134d02313a7e06d04944957cb9149a5069ebfcc65b58711afd15bfbe6f3144cf719a1d8c90833890d5ed1eac7e3b8a657a774a065ca04588c7743c47a41fe59e21cd7767a4" localRef="instance" location="sp.problem_size.Instance_SP/Instance_SP.hpe" name="Instance_SP" package="sp.problem_size" exposed="false">
      <visualDescription h="101" w="178" x="532" y="439">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="class" varName="C"/>
      <unitBounds uRef="instance">
        <visualDescription h="10" w="10" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000237f437b205f7bfa00c2d0b40167897c37f84c96a62c077e2832a5360fa8c1c7438dfa969d99bb36a48a7baefcbd50d84ae2e3e71a349dce24c2b0bc473997871be48fdb29d0d48b0928ca968440c6b6663c6740810dab7b664db0e0cfbfe5b21f223402d0d9bd601294898724b6a1da46e78261ef1ee37ac63ca9b2dbdc0d90" localRef="class" location="common.problem_size.Class/Class.hpe" name="Class" package="common.problem_size" exposed="false">
      <visualDescription h="30" w="50" x="305" y="419">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds uRef="class">
        <visualDescription h="10" w="10" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <supplyParameter cRef="class" varName="C"/>
    <supplyParameter cRef="instance" varName="I"/>
    <interface iRef="IProblemDefinitionImpl" nArgs="1">
      <slice isRef="us">
        <originRef cRef="us" iRef="IField"/>
        <visualDescription h="10" w="10" x="1" y="26"/>
      </slice>
      <slice isRef="vs">
        <originRef cRef="vs" iRef="IField"/>
        <visualDescription h="10" w="10" x="14" y="22"/>
      </slice>
      <slice isRef="ws">
        <originRef cRef="ws" iRef="IField"/>
        <visualDescription h="10" w="10" x="25" y="26"/>
      </slice>
      <slice isRef="qs">
        <originRef cRef="qs" iRef="IField"/>
        <visualDescription h="10" w="10" x="37" y="26"/>
      </slice>
      <slice isRef="rho">
        <originRef cRef="rho" iRef="IField"/>
        <visualDescription h="10" w="10" x="49" y="27"/>
      </slice>
      <slice isRef="ainv">
        <originRef cRef="ainv" iRef="IField"/>
        <visualDescription h="10" w="10" x="27" y="3"/>
      </slice>
      <slice isRef="speed">
        <originRef cRef="speed" iRef="IField"/>
        <visualDescription h="10" w="10" x="48" y="2"/>
      </slice>
      <slice isRef="u">
        <originRef cRef="u" iRef="IField"/>
        <visualDescription h="10" w="10" x="67" y="2"/>
      </slice>
      <slice isRef="forcing">
        <originRef cRef="forcing" iRef="IField"/>
        <visualDescription h="10" w="10" x="69" y="15"/>
      </slice>
      <slice isRef="rhs">
        <originRef cRef="rhs" iRef="IField"/>
        <visualDescription h="10" w="10" x="65" y="26"/>
      </slice>
      <slice isRef="lhs">
        <originRef cRef="lhs" iRef="IField"/>
        <visualDescription h="10" w="10" x="57" y="13"/>
      </slice>
      <slice isRef="square">
        <originRef cRef="square" iRef="IField"/>
        <visualDescription h="10" w="10" x="9" y="2"/>
      </slice>
      <slice isRef="instance">
        <originRef cRef="instance" iRef="IInstance"/>
        <visualDescription h="10" w="10" x="0" y="9"/>
      </slice>
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using common.data.Field;&#xA;using common.data.ProblemDefinition;&#xA;using common.problem_size.Class;&#xA;using common.problem_size.Instance;&#xA;&#xA;namespace impl.common.data.ProblemDefinition { &#xA;&#xA;public abstract class BaseIProblemDefinitionImpl: DataStructure, BaseIProblemDefinition&#xA;{&#xA;&#x9;&#x9;&#xA;private IInstance instance = null;&#xA;&#xA;protected IInstance Instance {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (instance==null) &#xA;&#x9;&#x9;&#x9;instance = (IInstance) Services.getPort(&quot;instance&quot;);&#xA;&#x9;&#x9;return instance;&#xA;&#x9;}&#xA;}&#x9;&#x9;&#xA;&#xA;private IField lhs = null;&#xA;&#xA;protected IField Lhs {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (lhs==null) &#xA;&#x9;&#x9;&#x9;lhs = (IField) Services.getPort(&quot;lhs&quot;);&#xA;&#x9;&#x9;return lhs;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField u = null;&#xA;&#xA;protected IField U {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (u == null) &#xA;&#x9;&#x9;&#x9;u = (IField) Services.getPort(&quot;u&quot;);&#xA;&#x9;&#x9;return u;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField us = null;&#xA;&#xA;protected IField Us {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (us == null) &#xA;&#x9;&#x9;&#x9;us = (IField) Services.getPort(&quot;us&quot;);&#xA;&#x9;&#x9;return us;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField vs = null;&#xA;&#xA;protected IField Vs {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (vs==null) &#xA;&#x9;&#x9;&#x9;vs = (IField) Services.getPort(&quot;vs&quot;);&#xA;&#x9;&#x9;return vs;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField ws = null;&#xA;&#xA;protected IField Ws {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (ws==null) &#xA;&#x9;&#x9;&#x9;ws = (IField) Services.getPort(&quot;ws&quot;);&#xA;&#x9;&#x9;return ws;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField qs = null;&#xA;&#xA;protected IField Qs {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (qs==null) &#xA;&#x9;&#x9;&#x9;qs = (IField) Services.getPort(&quot;qs&quot;);&#xA;&#x9;&#x9;return qs;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField rho = null;&#xA;&#xA;protected IField Rho {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (rho==null) &#xA;&#x9;&#x9;&#x9;rho = (IField) Services.getPort(&quot;rho&quot;);&#xA;&#x9;&#x9;return rho;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField ainv = null;&#xA;&#xA;protected IField Ainv {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (ainv==null) &#xA;&#x9;&#x9;&#x9;ainv = (IField) Services.getPort(&quot;ainv&quot;);&#xA;&#x9;&#x9;return ainv;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField speed = null;&#xA;&#xA;protected IField Speed {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (speed==null) &#xA;&#x9;&#x9;&#x9;speed = (IField) Services.getPort(&quot;speed&quot;);&#xA;&#x9;&#x9;return speed;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField square = null;&#xA;&#xA;protected IField Square {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (square==null) &#xA;&#x9;&#x9;&#x9;square = (IField) Services.getPort(&quot;square&quot;);&#xA;&#x9;&#x9;return square;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField rhs = null;&#xA;&#xA;protected IField Rhs {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (rhs==null) &#xA;&#x9;&#x9;&#x9;rhs = (IField) Services.getPort(&quot;rhs&quot;);&#xA;&#x9;&#x9;return rhs;&#xA;&#x9;}&#xA;}&#xA;&#xA;private IField forcing = null;&#xA;&#xA;protected IField Forcing {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (forcing==null) &#xA;&#x9;&#x9;&#x9;forcing = (IField) Services.getPort(&quot;forcing&quot;);&#xA;&#x9;&#x9;return rhs;&#xA;&#x9;}&#xA;}&#xA;&#xA;}&#xA;&#xA;}&#xA;" fileType="library" name="BaseIProblemDefinitionImpl.cs" srcType="base" uri="impl.common.data.ProblemDefinitionImpl/bin/1.0.0.0/BaseIProblemDefinitionImpl.dll" versionId="1.0.0.0">
          <dependency>common.data.Field/bin/1.0.0.0/IField.dll</dependency>
          <dependency>common.data.ProblemDefinition/bin/1.0.0.0/BaseIProblemDefinition.dll</dependency>
        </file>
        <file contents="using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using common.data.ProblemDefinition;&#xA;&#xA;namespace impl.common.data.ProblemDefinition { &#xA;&#xA;public class IProblemDefinitionImpl : BaseIProblemDefinitionImpl, IProblemDefinition&#xA;{&#xA;&#x9;&#x9;&#xA;&#x9;public char CLASS = 'S';&#xA;&#x9;&#xA;&#x9;protected int IMAX = 0, JMAX = 0, KMAX = 0, MAX_CELL_DIM = 0, BUF_SIZE = 0, IMAXP, JMAXP,&#xA;&#x9;&#x9;&#x9;&#x9;  problem_size = 0, maxcells = 0, ncells = 0;&#xA;&#x9;protected int[] grid_points = { 0, 0, 0 };&#xA;&#x9;protected int niter_default = 0;&#xA;&#x9;protected double dt_default = 0.0d;&#x9;&#x9;&#xA;&#x9;&#xA;&#x9;public int NCells { get { return ncells; } }&#xA;&#x9;&#x9;&#xA;&#x9;public double [,,,,] Field_u       { get { return U.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_rhs     { get { return Rhs.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_lhs     { get { return Lhs.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_forcing { get { return Forcing.Field; } }&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;public double [,,,,] Field_us       { get { return Us.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_vs       { get { return Vs.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_ws       { get { return Ws.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_qs       { get { return Qs.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_ainv     { get { return Ainv.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_rho      { get { return Rho.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_speed    { get { return Speed.Field; } }&#x9;&#xA;&#x9;public double [,,,,] Field_square   { get { return Square.Field; } }&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;public void initialize_problem_data(char clss) &#xA;&#x9;{&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;setProblemClass(clss);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;int total_nodes = this.Ranks.Length;&#xA;&#x9;&#x9;maxcells =  Convert.ToInt32(Math.Sqrt(total_nodes));&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;    MAX_CELL_DIM = (problem_size/maxcells)+1;                &#xA;&#x9;&#x9;IMAX = JMAX = KMAX = grid_points[0] = grid_points[1] = grid_points[2] = MAX_CELL_DIM;&#xA;&#x9;    IMAXP = IMAX/2 * 2 + 1;&#xA;&#x9;    JMAXP = JMAX/2 * 2 + 1;&#xA;&#x9;    // BUF_SIZE = MAX_CELL_DIM*MAX_CELL_DIM*(maxcells-1)*60*2+1;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;U.initialize_field(&quot;u&quot;,maxcells, KMAX+4,JMAXP+4,IMAXP+4, 5);&#xA;&#x9;&#x9;Rhs.initialize_field(&quot;rhs&quot;, maxcells, KMAX+2,JMAXP+2,IMAXP+2, 5);&#xA;&#x9;&#x9;Lhs.initialize_field(&quot;lhs&quot;, maxcells, KMAX+2,JMAXP+2,IMAXP+2, 15);&#xA;&#x9;&#x9;Forcing.initialize_field(&quot;forcing&quot;, maxcells, KMAX+2, JMAXP+2, IMAXP+2, 5);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Us.initialize_field(&quot;us&quot;, maxcells, KMAX+3, JMAX+3, IMAX+3);&#xA;&#x9;&#x9;Vs.initialize_field(&quot;vs&quot;, maxcells, KMAX+3, JMAX+3, IMAX+3);&#xA;&#x9;&#x9;Ws.initialize_field(&quot;ws&quot;, maxcells, KMAX+3, JMAX+3, IMAX+3);&#xA;&#x9;&#x9;Qs.initialize_field(&quot;qs&quot;, maxcells, KMAX+3, JMAX+3, IMAX+3);&#xA;&#x9;&#x9;Ainv.initialize_field(&quot;ainv&quot;, maxcells, KMAX+3, JMAX+3, IMAX+3);&#xA;&#x9;&#x9;Rho.initialize_field(&quot;rho&quot;, maxcells, KMAX+3, JMAX+3, IMAX+3);&#xA;&#x9;&#x9;Speed.initialize_field(&quot;speed&quot;, maxcells, KMAX+3, JMAX+3, IMAX+3);&#xA;&#x9;&#x9;Square.initialize_field(&quot;square&quot;, maxcells, KMAX+3, JMAX+3, IMAX+3);&#x9;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;private void setProblemClass(char clss) &#xA;&#x9;{&#xA;&#x9;            problem_size = Instance.problem_size;&#xA;&#x9;&#x9;&#x9;&#x9;dt_default = Instance.dt_default;&#xA;&#x9;&#x9;&#x9;&#x9;niter_default = Instance.niter_default;&#xA;&#xA;&#x9;/*&#x9;CLASS = clss;&#xA;&#x9;    &#xA;&#x9;&#x9;switch (clss)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;case 'S':&#xA;&#x9;            problem_size = 12;&#xA;&#x9;&#x9;&#x9;&#x9;dt_default = .015d;&#xA;&#x9;&#x9;&#x9;&#x9;niter_default = 100;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case 'W':&#xA;&#x9;&#x9;&#x9;&#x9;problem_size = 36;&#xA;&#x9;&#x9;&#x9;&#x9;dt_default = .0015d;&#xA;&#x9;&#x9;&#x9;&#x9;niter_default = 400;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case 'A':&#xA;&#x9;&#x9;&#x9;&#x9;problem_size = 64;&#xA;&#x9;&#x9;&#x9;&#x9;dt_default = .0015d;&#xA;&#x9;&#x9;&#x9;&#x9;niter_default = 400;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case 'B':&#xA;&#x9;&#x9;&#x9;&#x9;problem_size = 102;&#xA;&#x9;&#x9;&#x9;&#x9;dt_default = .001d;&#xA;&#x9;&#x9;&#x9;&#x9;niter_default = 400;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case 'C':&#xA;&#x9;&#x9;&#x9;&#x9;problem_size = 162;&#xA;&#x9;&#x9;&#x9;&#x9;dt_default = .00067d;&#xA;&#x9;&#x9;&#x9;&#x9;niter_default = 400;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;        default :&#xA;&#x9;            Console.WriteLine(&quot;: NO PROBLEM INSTANCE !!!&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;throw new Exception(&quot;NO PROBLEM INSTANCE&quot;);&#x9;&#x9;                    &#xA;&#x9;&#x9;}*/&#xA;&#x9;}&#x9;&#xA;&#x9;&#xA;&#x9;public void initialize()&#xA;&#x9;{&#xA;&#x9;&#x9;double[,,,,] u, rhs, forcing;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;u = Field_u;&#xA;&#x9;&#x9;rhs = Field_rhs;&#xA;&#x9;&#x9;forcing = Field_forcing;&#xA;&#x9;&#x9;&#x9;&#xA; &#xA;&#x9;&#x9;int c, i, j, k, m, ii, jj, kk, ix, iy, iz;&#xA;&#x9;&#x9;double xi, eta, zeta, Pxi, Peta, Pzeta; &#xA;&#x9;    double[] Pface = new double[5*3*2];&#xA;&#x9;&#x9;double[] temp = new double[5];&#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;//  Later (in compute_rhs) we compute 1/u for every element. A few of &#xA;&#x9;&#x9;//  the corner elements are not used, but it convenient (and faster) &#xA;&#x9;&#x9;//  to compute the whole thing with a simple loop. Make sure those &#xA;&#x9;&#x9;//  values are nonzero by initializing the whole thing here. &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;    for (c = 0; c &lt; ncells; c++)&#xA;&#x9;    {&#xA;&#x9;        for (k = 1; k &lt;= IMAX + 2; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = 1; j &lt;= IMAX + 2; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = 1; i &lt;= IMAX + 2; i++)&#xA;&#x9;                {&#xA;&#x9;                    u[c, k, j, i, 0] = 1.0d;&#xA;&#x9;                    u[c, k, j, i, 1] = 0.0d;&#xA;&#x9;                    u[c, k, j, i, 2] = 0.0d;&#xA;&#x9;                    u[c, k, j, i, 3] = 0.0d;&#xA;&#x9;                    u[c, k, j, i, 4] = 1.0d;&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;    }&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;// first store the &quot;interpolated&quot; values everywhere on the grid    &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;    for (c = 0; c &lt; maxcells; c++)&#xA;&#x9;    {&#xA;&#x9;        kk = 2;&#xA;&#x9;        for (k = cell_low[c,2]; k &lt;= cell_high[c,2]; k++)&#xA;&#x9;        {&#xA;&#x9;            zeta = k * dnzm1;&#xA;&#x9;            jj = 2;&#xA;&#x9;            for (j = cell_low[c,1]; j &lt;= cell_high[c,1]; j++)&#xA;&#x9;            {&#xA;&#x9;                eta = j * dnym1;&#xA;&#x9;                ii = 2;&#xA;&#x9;                for (i = cell_low[c,0]; i &lt;= cell_high[c,0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    xi = i * dnxm1;&#xA;&#x9;&#xA;&#x9;                    for (ix = 0; ix &lt;= 1; ix++)&#xA;&#x9;                    {&#xA;&#x9;                        exact_solution(ix, eta, zeta, Pface, 0 + 0 * 5 + ix * 15);&#xA;&#x9;                    }&#xA;&#x9;                    for (iy = 0; iy &lt;= 1; iy++)&#xA;&#x9;                    {&#xA;&#x9;                        exact_solution(xi, iy, zeta, Pface, 0 + 1 * 5 + iy * 15);&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    for (iz = 0; iz &lt;= 1; iz++)&#xA;&#x9;                    {&#xA;&#x9;                        exact_solution(xi, eta, iz, Pface, 0 + 2 * 5 + iz * 15);&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        Pxi = xi * Pface[m + 0 * 5 + 1 * 15] +&#xA;&#x9;                            (1.0d - xi) * Pface[m + 0 * 5 + 0 * 15];&#xA;&#x9;                        Peta = eta * Pface[m + 1 * 5 + 1 * 15] +&#xA;&#x9;                                (1.0d - eta) * Pface[m + 1 * 5 + 0 * 15];&#xA;&#x9;                        Pzeta = zeta * Pface[m + 2 * 5 + 1 * 15] +&#xA;&#x9;                                (1.0d - zeta) * Pface[m + 2 * 5 + 0 * 15];&#xA;&#x9;&#xA;&#x9;                        u[c, kk, jj, ii, m] =&#xA;&#x9;                          Pxi + Peta + Pzeta -&#xA;&#x9;                                  Pxi * Peta - Pxi * Pzeta - Peta * Pzeta +&#xA;&#x9;                                  Pxi * Peta * Pzeta;&#xA;&#x9;                    }&#xA;&#x9;                    ii++;&#xA;&#x9;                }&#xA;&#x9;                jj++;&#xA;&#x9;            }&#xA;&#x9;            kk++;&#xA;&#x9;        }&#xA;&#x9;    }&#xA;&#x9;    &#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;// now store the exact values on the boundaries        &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;// west face                                                  &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;    c = slice[0, 0];&#xA;&#x9;    ii = 2;&#xA;&#x9;&#x9;xi = 0.0d;&#xA;&#x9;&#x9;kk = 2;&#xA;&#x9;&#x9;for (k = cell_low[c,2]; k &lt;= cell_high[c,2]; k++)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;zeta = k * dnzm1;&#xA;&#x9;        jj = 2;&#xA;&#x9;&#x9;&#x9;for (j = cell_low[c,1]; j &lt;= cell_high[c,1]; j++)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;eta = j * dnym1;&#xA;&#x9;&#x9;&#x9;&#x9;exact_solution(xi, eta, zeta, temp, 0);&#xA;&#x9;&#x9;&#x9;&#x9;for (m = 0; m &lt; 5 ; m++)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;                u[c, kk, jj, ii, m] = temp[m];&#xA;&#x9;            }&#xA;&#x9;            jj++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;        kk++;&#xA;&#x9;&#x9;}&#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;// east face                                                      &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;    c = slice[ncells - 1, 0];&#xA;&#x9;    ii = 2 + cell_size[c, 0] - 1;&#xA;&#x9;&#x9;xi = 1.0d;&#xA;&#x9;    kk = 2;&#xA;&#x9;&#x9;for (k = cell_low[c,2]; k &lt;= cell_high[c,2]; k++)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;zeta = k * dnzm1;&#xA;&#x9;        jj = 2;&#xA;&#x9;&#x9;&#x9;for (j = cell_low[c,1]; j &lt;= cell_high[c,1]; j++)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;            eta = j * dnym1;&#xA;&#x9;&#x9;&#x9;&#x9;exact_solution(xi, eta, zeta, temp, 0);&#xA;&#x9;&#x9;&#x9;&#x9;for (m = 0; m &lt;= 4; m++)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;                u[c, kk, jj, ii, m] = temp[m];&#xA;&#x9;            }&#xA;&#x9;            jj++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;        kk++;&#xA;&#x9;&#x9;}&#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;// south face                                                 &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;    c = slice[0,1];&#xA;&#x9;    jj = 2;&#xA;&#x9;&#x9;eta = 0.0d;&#xA;&#x9;&#x9;kk = 2;&#xA;&#x9;&#x9;for (k = cell_low[c,2]; k &lt;= cell_high[c,2]; k++)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;zeta = k * dnzm1;&#xA;&#x9;        ii = 2;&#xA;&#x9;&#x9;&#x9;for (i = cell_low[c,0]; i &lt;= cell_high[c,0]; i++)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;xi = i * dnxm1;&#xA;&#x9;&#x9;&#x9;&#x9;exact_solution(xi, eta, zeta, temp, 0);&#xA;&#x9;&#x9;&#x9;&#x9;for (m = 0; m &lt;= 4; m++)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;                u[c, kk, jj, ii, m] = temp[m];&#xA;&#x9;            }&#xA;&#x9;            ii++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;        kk++;&#xA;&#x9;&#x9;}&#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;// north face                                    &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;    c = slice[ncells - 1, 1];&#xA;&#x9;    jj = 2 + cell_size[c, 1] - 1;&#xA;&#x9;&#x9;eta = 1.0d;&#xA;&#x9;    kk = 2;&#xA;&#x9;&#x9;for (k = cell_low[c,2]; k &lt;= cell_high[c,2]; k++)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;zeta = k * dnzm1;&#xA;&#x9;        ii = 2;&#xA;&#x9;        for (i = cell_low[c,0]; i &lt;= cell_high[c,0]; i++)&#xA;&#x9;        {&#xA;&#x9;            xi = i * dnxm1;&#xA;&#x9;            exact_solution(xi, eta, zeta, temp, 0);&#xA;&#x9;            for (m = 0; m &lt;= 4; m++)&#xA;&#x9;            {&#xA;&#x9;                u[c, kk, jj, ii, m] = temp[m];&#xA;&#x9;            }&#xA;&#x9;            ii++;&#xA;&#x9;        }&#xA;&#x9;        kk++;&#xA;&#x9;&#x9;}&#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;// bottom face                                       &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;    c = slice[0, 2];&#xA;&#x9;    kk = 2;&#xA;&#x9;&#x9;zeta = 0.0d;&#xA;&#x9;&#x9;jj = 2;&#xA;&#x9;    for (j = cell_low[c, 1]; j &lt;= cell_high[c, 1]; j++)&#xA;&#x9;    {&#xA;&#x9;        eta = j * dnym1;&#xA;&#x9;        ii = 2;&#xA;&#x9;        for (i = cell_low[c, 0]; i &lt;= cell_high[c, 0]; i++)&#xA;&#x9;        {&#xA;&#x9;            xi = i * dnxm1;&#xA;&#x9;            exact_solution(xi, eta, zeta, temp, 0);&#xA;&#x9;            for (m = 0; m &lt;= 4; m++)&#xA;&#x9;            {&#xA;&#x9;                u[c, kk, jj, ii, m] = temp[m];&#xA;&#x9;            }&#xA;&#x9;            ii++;&#xA;&#x9;        }&#xA;&#x9;        jj++;&#xA;&#x9;    }&#xA;&#x9;&#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#x9;// top face     &#xA;&#x9;&#x9;//---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;    c = slice[ncells - 1, 2];&#xA;&#x9;    kk = 2 + cell_size[c, 2] - 1;&#xA;&#x9;&#x9;zeta = 1.0d;&#xA;&#x9;    jj = 2;&#xA;&#x9;&#x9;for (j = cell_low[c,1]; j &lt;= cell_high[c,1]; j++)&#xA;&#x9;&#x9;{&#xA;&#x9;        eta = j * dnym1;&#xA;&#x9;        ii = 2;&#xA;&#x9;&#x9;&#x9;for (i = cell_low[c,0]; i &lt;= cell_high[c,0]; i++)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;            xi = i * dnxm1;&#xA;&#x9;            exact_solution(xi, eta, zeta, temp, 0);&#xA;&#x9;&#x9;&#x9;&#x9;for (m = 0; m &lt;= 4; m++)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;u[c, kk, jj, ii, m] = temp[m];&#xA;&#x9;            }&#xA;&#x9;            ii++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;        jj++;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;public void lhsinit()&#xA;&#x9;{&#xA;&#x9;&#xA;&#x9;    //---------------------------------------------------------------------&#xA;&#x9;    // loop over all cells                                       &#xA;&#x9;    //---------------------------------------------------------------------&#xA;&#x9;    for (int c = 0; c &lt; ncells; c++)&#xA;&#x9;    {&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        // first, initialize the start and end arrays&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;        for (int d = 0; d &lt; 3; d++)&#xA;&#x9;        {&#xA;&#x9;            if (cell_coord[c, d] == 0)&#xA;&#x9;                start[c, d] = 3;&#xA;&#x9;            else&#xA;&#x9;                start[c, d] = 2;&#xA;&#x9;&#xA;&#x9;            if (cell_coord[c, d] == ncells - 1)&#xA;&#x9;                end[c, d] = 1;&#xA;&#x9;            else&#xA;&#x9;                end[c, d] = 0;&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        // zap the whole left hand side for starters&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;        for (int k = 2; k &lt; 2 + cell_size[c, 2]; k++)&#xA;&#x9;        {&#xA;&#x9;            for (int j = 2; j &lt; 2 + cell_size[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (int i = 2; i &lt; 2 + cell_size[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (int n = 0; n &lt; 15; n++)&#xA;&#x9;                    {&#xA;&#x9;                        lhs[c, k, j, i, n] = 0.0d;&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        // next, set all diagonal values to 1. This is overkill, but convenient&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;        for (int n = 0; n &lt; 3; n++)&#xA;&#x9;        {&#xA;&#x9;            for (int k = 2; k &lt; 2 + cell_size[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (int j = 2; j &lt; 2 + cell_size[c, 1]; j++)&#xA;&#x9;                {&#xA;&#x9;                    for (int i = 2; i &lt; 2 + cell_size[c, 0]; i++)&#xA;&#x9;                    {&#xA;&#x9;                        lhs[c, k, j, i, 5 * n + 2] = 1.0d;&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;    }&#xA;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;public void exact_rhs()&#xA;&#x9;    {&#xA;&#x9;&#x9;&#x9;double[,] ue, buf;&#xA;&#x9;&#x9;    double[] cuf, q;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;        double[] dtemp = new double[5];&#xA;&#x9;        double xi, eta, zeta, dtpp;&#xA;&#x9;        int c, m, i, j, k, ip1, im1, jp1, jm1, km1, kp1, ksize, jsize, isize;&#xA;&#x9;&#xA;&#x9;        // int ii, jj, kk;  /* +2 offset required by C# arrays for Fortran with -2 lower limit */&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;        for (c = 0; c &lt; ncells; c++)&#xA;&#x9;        {&#xA;&#x9;            ksize = cell_size[c, 2] + 2;&#xA;&#x9;            jsize = cell_size[c, 1] + 2;&#xA;&#x9;            isize = cell_size[c, 0] + 2;&#xA;&#x9;&#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            //      initialize                                  &#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            for (m = 0; m &lt; 5; m++)&#xA;&#x9;            {&#xA;&#x9;                for (k = 2; k &lt; ksize; k++)&#xA;&#x9;                {&#xA;&#x9;                    for (j = 2; j &lt; jsize; j++)&#xA;&#x9;                    {&#xA;&#x9;                        for (i = 2; i &lt; isize; i++)&#xA;&#x9;                        {&#xA;&#x9;                            forcing[c, k, j, i, m] = 0.0d;&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            //      xi-direction flux differences                      &#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                zeta = (k - 2 + cell_low[c, 2]) * dnzm1;&#xA;&#x9;                for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;                {&#xA;&#x9;                    eta = (j - 2 + cell_low[c, 1]) * dnym1;&#xA;&#x9;                    for (i = 2 * start[c, 0] - 4; i &lt;= isize + 1 - 2 * end[c, 0]; i++)&#xA;&#x9;                    {&#xA;&#x9;                        xi = (i - 2 + cell_low[c, 0]) * dnxm1;&#xA;&#x9;&#xA;&#x9;                        exact_solution(xi, eta, zeta, dtemp, 0);&#xA;&#x9;                        for (m = 0; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            ue[i, m] = dtemp[m]; // OK ue[i,m]&#xA;&#x9;                        }&#xA;&#x9;&#xA;&#x9;                        dtpp = 1.0d / dtemp[0];&#xA;&#x9;&#xA;&#x9;                        for (m = 1; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            buf[i, m] = dtpp * dtemp[m]; // OK buf[i,m]&#xA;&#x9;                        }&#xA;&#x9;&#xA;&#x9;                        cuf[i] = buf[i, 1] * buf[i, 1];&#xA;&#x9;                        buf[i, 0] = cuf[i] + buf[i, 2] * buf[i, 2] +&#xA;&#x9;                                             buf[i, 3] * buf[i, 3];&#xA;&#x9;                        q[i] = 0.5d * (buf[i, 1] * ue[i, 1] + buf[i, 2] * ue[i, 2] +&#xA;&#x9;                                                             buf[i, 3] * ue[i, 3]);&#xA;&#x9;                        // OK cuf[i], buf[i,0], q[i]&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                    {&#xA;&#x9;                        im1 = i - 1;&#xA;&#x9;                        ip1 = i + 1;&#xA;&#x9;&#xA;&#x9;                        double b = forcing[c, k, j, i, 0];&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 0] = forcing[c, k, j, i, 0] -&#xA;&#x9;                                         tx2 * (ue[ip1, 1] - ue[im1, 1]) +&#xA;&#x9;                                         dx1tx1 * (ue[ip1, 0] - 2.0d * ue[i, 0] + ue[im1, 0]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 1] = forcing[c, k, j, i, 1] - tx2 * (&#xA;&#x9;                                        (ue[ip1, 1] * buf[ip1, 1] + c2 * (ue[ip1, 4] - q[ip1])) -&#xA;&#x9;                                        (ue[im1, 1] * buf[im1, 1] + c2 * (ue[im1, 4] - q[im1]))) +&#xA;&#x9;                                         xxcon1 * (buf[ip1, 1] - 2.0d * buf[i, 1] + buf[im1, 1]) +&#xA;&#x9;                                         dx2tx1 * (ue[ip1, 1] - 2.0d * ue[i, 1] + ue[im1, 1]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 2] = forcing[c, k, j, i, 2] - tx2 * (&#xA;&#x9;                                         ue[ip1, 2] * buf[ip1, 1] - ue[im1, 2] * buf[im1, 1]) +&#xA;&#x9;                                         xxcon2 * (buf[ip1, 2] - 2.0d * buf[i, 2] + buf[im1, 2]) +&#xA;&#x9;                                         dx3tx1 * (ue[ip1, 2] - 2.0d * ue[i, 2] + ue[im1, 2]);&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 3] = forcing[c, k, j, i, 3] - tx2 * (&#xA;&#x9;                                         ue[ip1, 3] * buf[ip1, 1] - ue[im1, 3] * buf[im1, 1]) +&#xA;&#x9;                                         xxcon2 * (buf[ip1, 3] - 2.0d * buf[i, 3] + buf[im1, 3]) +&#xA;&#x9;                                         dx4tx1 * (ue[ip1, 3] - 2.0d * ue[i, 3] + ue[im1, 3]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 4] = forcing[c, k, j, i, 4] - tx2 * (&#xA;&#x9;                                         buf[ip1, 1] * (c1 * ue[ip1, 4] - c2 * q[ip1]) -&#xA;&#x9;                                         buf[im1, 1] * (c1 * ue[im1, 4] - c2 * q[im1])) +&#xA;&#x9;                                         0.5d * xxcon3 * (buf[ip1, 0] - 2.0d * buf[i, 0] +&#xA;&#x9;                                                       buf[im1, 0]) +&#xA;&#x9;                                         xxcon4 * (cuf[ip1] - 2.0d * cuf[i] + cuf[im1]) +&#xA;&#x9;                                         xxcon5 * (buf[ip1, 4] - 2.0d * buf[i, 4] + buf[im1, 4]) +&#xA;&#x9;                                         dx5tx1 * (ue[ip1, 4] - 2.0d * ue[i, 4] + ue[im1, 4]);&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    //---------------------------------------------------------------------&#xA;&#x9;                    //            Fourth-order dissipation                         &#xA;&#x9;                    //---------------------------------------------------------------------&#xA;&#x9;                    if (start[c, 0] > 2)&#xA;&#x9;                    {&#xA;&#x9;                        &#xA;&#x9;                        for (m = 0; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            i = 3;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                                (5.0d * ue[i, m] - 4.0d * ue[i + 1, m] + ue[i + 2, m]);&#xA;&#x9;                            i = 4;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                               (-4.0d * ue[i - 1, m] + 6.0d * ue[i, m] -&#xA;&#x9;                                                 4.0d * ue[i + 1, m] + ue[i + 2, m]);&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        for (i = 3 * start[c, 0] - 4; i &lt; isize - 3 * end[c, 0]; i++)&#xA;&#x9;                        {&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                             (ue[i - 2, m] - 4.0d * ue[i - 1, m] +&#xA;&#x9;                                              6.0d * ue[i, m] - 4.0d * ue[i + 1, m] + ue[i + 2, m]);&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    if (end[c, 0] > 0)&#xA;&#x9;                    {&#xA;&#x9;                        for (m = 0; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            i = isize - 3;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                               (ue[i - 2, m] - 4.0d * ue[i - 1, m] +&#xA;&#x9;                                                6.0d * ue[i, m] - 4.0d * ue[i + 1, m]);&#xA;&#x9;                            i = isize - 2;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                               (ue[i - 2, m] - 4.0d * ue[i - 1, m] + 5.0d * ue[i, m]);&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            } // end k&#xA;&#x9;&#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            //  eta-direction flux differences             &#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                zeta = (k - 2 + cell_low[c, 2]) * dnzm1;&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    xi = (i - 2 + cell_low[c, 0]) * dnxm1;&#xA;&#x9;&#xA;&#x9;                    for (j = 2 * start[c, 1] - 4; j &lt;= jsize + 1 - 2 * end[c, 1]; j++)&#xA;&#x9;                    {&#xA;&#x9;                        eta = (j - 2 + cell_low[c, 1]) * dnym1;&#xA;&#x9;&#xA;&#x9;                        exact_solution(xi, eta, zeta, dtemp, 0);&#xA;&#x9;                        for (m = 0; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            ue[j, m] = dtemp[m];&#xA;&#x9;                        }&#xA;&#x9;                        dtpp = 1.0d / dtemp[0];&#xA;&#x9;&#xA;&#x9;                        for (m = 1; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            buf[j, m] = dtpp * dtemp[m];&#xA;&#x9;                        }&#xA;&#x9;&#xA;&#x9;                        cuf[j] = buf[j, 2] * buf[j, 2];&#xA;&#x9;                        buf[j, 0] = cuf[j] + buf[j, 1] * buf[j, 1] +&#xA;&#x9;                                             buf[j, 3] * buf[j, 3];&#xA;&#x9;                        q[j] = 0.5d * (buf[j, 1] * ue[j, 1] +&#xA;&#x9;                                      buf[j, 2] * ue[j, 2] +&#xA;&#x9;                                      buf[j, 3] * ue[j, 3]);&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;                    {&#xA;&#x9;                        jm1 = j - 1;&#xA;&#x9;                        jp1 = j + 1;&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 0] = forcing[c, k, j, i, 0] -&#xA;&#x9;                              ty2 * (ue[jp1, 2] - ue[jm1, 2]) +&#xA;&#x9;                              dy1ty1 * (ue[jp1, 0] - 2.0d * ue[j, 0] + ue[jm1, 0]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 1] = forcing[c, k, j, i, 1] - ty2 * (&#xA;&#x9;                              ue[jp1, 1] * buf[jp1, 2] - ue[jm1, 1] * buf[jm1, 2]) +&#xA;&#x9;                              yycon2 * (buf[jp1, 1] - 2.0d * buf[j, 1] + buf[jm1, 1]) +&#xA;&#x9;                              dy2ty1 * (ue[jp1, 1] - 2.0d * ue[j, 1] + ue[jm1, 1]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 2] = forcing[c, k, j, i, 2] - ty2 * (&#xA;&#x9;                              (ue[jp1, 2] * buf[jp1, 2] + c2 * (ue[jp1, 4] - q[jp1])) -&#xA;&#x9;                              (ue[jm1, 2] * buf[jm1, 2] + c2 * (ue[jm1, 4] - q[jm1]))) +&#xA;&#x9;                              yycon1 * (buf[jp1, 2] - 2.0d * buf[j, 2] + buf[jm1, 2]) +&#xA;&#x9;                              dy3ty1 * (ue[jp1, 2] - 2.0d * ue[j, 2] + ue[jm1, 2]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 3] = forcing[c, k, j, i, 3] - ty2 * (&#xA;&#x9;                              ue[jp1, 3] * buf[jp1, 2] - ue[jm1, 3] * buf[jm1, 2]) +&#xA;&#x9;                              yycon2 * (buf[jp1, 3] - 2.0d * buf[j, 3] + buf[jm1, 3]) +&#xA;&#x9;                              dy4ty1 * (ue[jp1, 3] - 2.0d * ue[j, 3] + ue[jm1, 3]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 4] = forcing[c, k, j, i, 4] - ty2 * (&#xA;&#x9;                              buf[jp1, 2] * (c1 * ue[jp1, 4] - c2 * q[jp1]) -&#xA;&#x9;                              buf[jm1, 2] * (c1 * ue[jm1, 4] - c2 * q[jm1])) +&#xA;&#x9;                              0.5d * yycon3 * (buf[jp1, 0] - 2.0d * buf[j, 0] +&#xA;&#x9;                                            buf[jm1, 0]) +&#xA;&#x9;                              yycon4 * (cuf[jp1] - 2.0d * cuf[j] + cuf[jm1]) +&#xA;&#x9;                              yycon5 * (buf[jp1, 4] - 2.0d * buf[j, 4] + buf[jm1, 4]) +&#xA;&#x9;                              dy5ty1 * (ue[jp1, 4] - 2.0d * ue[j, 4] + ue[jm1, 4]);&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    //---------------------------------------------------------------------&#xA;&#x9;                    //            Fourth-order dissipation                      &#xA;&#x9;                    //---------------------------------------------------------------------&#xA;&#x9;                    if (start[c, 1] > 2)&#xA;&#x9;                    {&#xA;&#x9;                        for (m = 0; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            j = 3;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                      (5.0d * ue[j, m] - 4.0d * ue[j + 1, m] + ue[j + 2, m]);&#xA;&#x9;                            j = 4;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                     (-4.0d * ue[j - 1, m] + 6.0d * ue[j, m] -&#xA;&#x9;                                       4.0d * ue[j + 1, m] + ue[j + 2, m]);&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        for (j = 3 * start[c, 1] - 4; j &lt; jsize - 3 * end[c, 1]; j++)&#xA;&#x9;                        {&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                  (ue[j - 2, m] - 4.0d * ue[j - 1, m] +&#xA;&#x9;                                   6.0d * ue[j, m] - 4.0d * ue[j + 1, m] + ue[j + 2, m]);&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    if (end[c, 1] > 0)&#xA;&#x9;                    {&#xA;&#x9;                        for (m = 0; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            j = jsize - 3;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                     (ue[j - 2, m] - 4.0d * ue[j - 1, m] +&#xA;&#x9;                                      6.0d * ue[j, m] - 4.0d * ue[j + 1, m]);&#xA;&#x9;                            j = jsize - 2;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                     (ue[j - 2, m] - 4.0d * ue[j - 1, m] + 5.0d * ue[j, m]);&#xA;&#x9;&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            //      zeta-direction flux differences                      &#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                eta = (j - 2 + cell_low[c, 1]) * dnym1;&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    xi = (i - 2 + cell_low[c, 0]) * dnxm1;&#xA;&#x9;&#xA;&#x9;                    for (k = 2 * start[c, 2] - 4; k &lt;= ksize + 1 - 2 * end[c, 2]; k++)&#xA;&#x9;                    {&#xA;&#x9;                        zeta = (k - 2 + cell_low[c, 2]) * dnzm1;&#xA;&#x9;&#xA;&#x9;                        exact_solution(xi, eta, zeta, dtemp, 0);&#xA;&#x9;                        for (m = 0; m &lt;= 4; m++)&#xA;&#x9;                        {&#xA;&#x9;                            ue[k, m] = dtemp[m];&#xA;&#x9;                        }&#xA;&#x9;&#xA;&#x9;                        dtpp = 1.0d / dtemp[0];&#xA;&#x9;&#xA;&#x9;                        for (m = 1; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            buf[k, m] = dtpp * dtemp[m];&#xA;&#x9;                        }&#xA;&#x9;&#xA;&#x9;                        cuf[k] = buf[k, 3] * buf[k, 3];&#xA;&#x9;                        buf[k, 0] = cuf[k] + buf[k, 1] * buf[k, 1] +&#xA;&#x9;                                   buf[k, 2] * buf[k, 2];&#xA;&#x9;                        q[k] = 0.5d * (buf[k, 1] * ue[k, 1] + buf[k, 2] * ue[k, 2] +&#xA;&#x9;                                      buf[k, 3] * ue[k, 3]);&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;                    {&#xA;&#x9;                        km1 = k - 1;&#xA;&#x9;                        kp1 = k + 1;&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 0] = forcing[c, k, j, i, 0] -&#xA;&#x9;                               tz2 * (ue[kp1, 3] - ue[km1, 3]) +&#xA;&#x9;                               dz1tz1 * (ue[kp1, 0] - 2.0d * ue[k, 0] + ue[km1, 0]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 1] = forcing[c, k, j, i, 1] - tz2 * (&#xA;&#x9;                               ue[kp1, 1] * buf[kp1, 3] - ue[km1, 1] * buf[km1, 3]) +&#xA;&#x9;                               zzcon2 * (buf[kp1, 1] - 2.0d * buf[k, 1] + buf[km1, 1]) +&#xA;&#x9;                               dz2tz1 * (ue[kp1, 1] - 2.0d * ue[k, 1] + ue[km1, 1]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 2] = forcing[c, k, j, i, 2] - tz2 * (&#xA;&#x9;                               ue[kp1, 2] * buf[kp1, 3] - ue[km1, 2] * buf[km1, 3]) +&#xA;&#x9;                               zzcon2 * (buf[kp1, 2] - 2.0d * buf[k, 2] + buf[km1, 2]) +&#xA;&#x9;                               dz3tz1 * (ue[kp1, 2] - 2.0d * ue[k, 2] + ue[km1, 2]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 3] = forcing[c, k, j, i, 3] - tz2 * (&#xA;&#x9;                              (ue[kp1, 3] * buf[kp1, 3] + c2 * (ue[kp1, 4] - q[kp1])) -&#xA;&#x9;                              (ue[km1, 3] * buf[km1, 3] + c2 * (ue[km1, 4] - q[km1]))) +&#xA;&#x9;                              zzcon1 * (buf[kp1, 3] - 2.0d * buf[k, 3] + buf[km1, 3]) +&#xA;&#x9;                              dz4tz1 * (ue[kp1, 3] - 2.0d * ue[k, 3] + ue[km1, 3]);&#xA;&#x9;&#xA;&#x9;                        forcing[c, k, j, i, 4] = forcing[c, k, j, i, 4] - tz2 * (&#xA;&#x9;                               buf[kp1, 3] * (c1 * ue[kp1, 4] - c2 * q[kp1]) -&#xA;&#x9;                               buf[km1, 3] * (c1 * ue[km1, 4] - c2 * q[km1])) +&#xA;&#x9;                               0.5d * zzcon3 * (buf[kp1, 0] - 2.0d * buf[k, 0]&#xA;&#x9;                                            + buf[km1, 0]) +&#xA;&#x9;                               zzcon4 * (cuf[kp1] - 2.0d * cuf[k] + cuf[km1]) +&#xA;&#x9;                               zzcon5 * (buf[kp1, 4] - 2.0d * buf[k, 4] + buf[km1, 4]) +&#xA;&#x9;                               dz5tz1 * (ue[kp1, 4] - 2.0d * ue[k, 4] + ue[km1, 4]);&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    //---------------------------------------------------------------------&#xA;&#x9;                    //            Fourth-order dissipation&#xA;&#x9;                    //---------------------------------------------------------------------&#xA;&#x9;                    if (start[c, 2] > 2)&#xA;&#x9;                    {&#xA;&#x9;                        for (m = 0; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            k = 3;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                      (5.0d * ue[k, m] - 4.0d * ue[k + 1, m] + ue[k + 2, m]);&#xA;&#x9;                            k = 4;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                     (-4.0d * ue[k - 1, m] + 6.0d * ue[k, m] -&#xA;&#x9;                                       4.0d * ue[k + 1, m] + ue[k + 2, m]);&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        for (k = 3 * start[c, 2] - 4; k &lt; ksize - 3 * end[c, 2]; k++)&#xA;&#x9;                        {&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                  (ue[k - 2, m] - 4.0d * ue[k - 1, m] +&#xA;&#x9;                                   6.0d * ue[k, m] - 4.0d * ue[k + 1, m] + ue[k + 2, m]);&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;&#xA;&#x9;                    if (end[c, 2] > 0)&#xA;&#x9;                    {&#xA;&#x9;                        for (m = 0; m &lt; 5; m++)&#xA;&#x9;                        {&#xA;&#x9;                            k = ksize - 3;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                     (ue[k - 2, m] - 4.0d * ue[k - 1, m] +&#xA;&#x9;                                      6.0d * ue[k, m] - 4.0d * ue[k + 1, m]);&#xA;&#x9;                            k = ksize - 2;&#xA;&#x9;                            forcing[c, k, j, i, m] = forcing[c, k, j, i, m] - dssp *&#xA;&#x9;                                  (ue[k - 2, m] - 4.0d * ue[k - 1, m] + 5.0d * ue[k, m]);&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            // now change the sign of the forcing function, &#xA;&#x9;            //---------------------------------------------------------------------&#xA;&#x9;            for (m = 0; m &lt; 5; m++)&#xA;&#x9;            {&#xA;&#x9;                for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;                {&#xA;&#x9;                    for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;                    {&#xA;&#x9;                        for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                        {&#xA;&#x9;                            forcing[c, k, j, i, m] = -1.0d * forcing[c, k, j, i, m];&#xA;&#x9;                        }&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        } // cell loop&#xA;&#x9;    }&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;}&#xA;&#xA;}&#xA;" fileType="library" name="IProblemDefinitionImpl.cs" srcType="user" uri="impl.common.data.ProblemDefinitionImpl/bin/1.0.0.0/IProblemDefinitionImpl.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/impl.common.data.ProblemDefinitionImpl/bin/1.0.0.0/BaseIProblemDefinitionImpl.dll</dependency>
          <dependency>common.data.ProblemDefinition/bin/1.0.0.0/IProblemDefinition.dll</dependency>
        </file>
      </sources>
      <visualDescription h="88" w="132" x="130" y="58">
        <color b="0" g="255" r="0"/>
      </visualDescription>
      <parameter iname="IInstance" order="0" parid="instance_type" uname="instance" varid="I"/>
    </interface>
    <unit iRef="IProblemDefinitionImpl" private="false" uRef="problem" visibleInterface="true">
      <super cRef="base" uRef="problem"/>
      <slices cRef="us" replica="0" uRef="field" sliceName="us" transitive="false">
        <visualDescription h="10" w="10" x="1" y="26"/>
      </slices>
      <slices cRef="vs" replica="0" uRef="field" sliceName="vs" transitive="false">
        <visualDescription h="10" w="10" x="14" y="22"/>
      </slices>
      <slices cRef="ws" replica="0" uRef="field" sliceName="ws" transitive="false">
        <visualDescription h="10" w="10" x="25" y="26"/>
      </slices>
      <slices cRef="qs" replica="0" uRef="field" sliceName="qs" transitive="false">
        <visualDescription h="10" w="10" x="37" y="26"/>
      </slices>
      <slices cRef="rho" replica="0" uRef="field" sliceName="rho" transitive="false">
        <visualDescription h="10" w="10" x="49" y="27"/>
      </slices>
      <slices cRef="ainv" replica="0" uRef="field" sliceName="ainv" transitive="false">
        <visualDescription h="10" w="10" x="27" y="3"/>
      </slices>
      <slices cRef="speed" replica="0" uRef="field" sliceName="speed" transitive="false">
        <visualDescription h="10" w="10" x="48" y="2"/>
      </slices>
      <slices cRef="u" replica="0" uRef="field" sliceName="u" transitive="false">
        <visualDescription h="10" w="10" x="67" y="2"/>
      </slices>
      <slices cRef="forcing" replica="0" uRef="field" sliceName="forcing" transitive="false">
        <visualDescription h="10" w="10" x="69" y="15"/>
      </slices>
      <slices cRef="rhs" replica="0" uRef="field" sliceName="rhs" transitive="false">
        <visualDescription h="10" w="10" x="65" y="26"/>
      </slices>
      <slices cRef="lhs" replica="0" uRef="field" sliceName="lhs" transitive="false">
        <visualDescription h="10" w="10" x="57" y="13"/>
      </slices>
      <slices cRef="square" replica="0" uRef="field" sliceName="square" transitive="false">
        <visualDescription h="10" w="10" x="9" y="2"/>
      </slices>
      <slices cRef="instance" replica="0" uRef="instance" sliceName="instance" transitive="false">
        <visualDescription h="10" w="10" x="0" y="9"/>
      </slices>
      <visualDescription h="40" w="80" x="170" y="183"/>
    </unit>
    <enumerator cardinality="-1" fromSplit="false" ref="hPE.frontend.base.model.HReplicator@1b2533d1295099559883" varId="n">
      <originRef>base</originRef>
      <originRef>speed</originRef>
      <links xsi:type="component:EnumerableUnitType" ref="problem"/>
      <visualDescription h="60" w="61" x="31" y="251"/>
    </enumerator>
  </componentInfo>
</component:component>