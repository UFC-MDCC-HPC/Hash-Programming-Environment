<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000c529e36a6fc6d06d4b6def2307c75249ae24c826ccc5e2c99668fa2d837b0f76b7e937ecfd3fb0aa678f1f4646c82e39d8e40a99fd0f014259fb265eb9bdaaf6bc8d9fe1c1d9d123a8b205be929329d947f8e3673d527df1d72736c5d275e47a19795a4a8d92aa785cb860f43c0e0106a33ef6e10f5240219b9b934a48bd7086" isAbstract="false" kind="Computation" name="ComputeRHSImpl" packagePath="impl.common">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000ebcd15c87001f794ff5f45146cc1149ff6b1cc732402e8fea7669e809f5f7ca7d0f449f36406e3c799d858b0df7c7ea46ed476b25ab2dd86f2147c5bd5aaa2723be2e0773163d3ebf363f88058c611ae190b35a5e11b2895c6b6ac55d7bcf8fcc96fb463cbf025e6a692e7bed5c86f5b14574041cbb0c132eba6f2deec770097" localRef="base" location="common.ComputeRHS/ComputeRHS.hpe" name="ComputeRHS" package="common" version="1.0.0.0">
        <visualDescription h="49" w="95" x="332" y="161">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <parameter formFieldId="instance_type" varName="I"/>
        <parameter formFieldId="class" varName="C"/>
        <port hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000cfe94b8926d4a7de4f70d204303375a68658c9c988f5e0ec7f1f3dce28b75501399411f8002d0637e06b03a2849ef779a22e26ae137759213f595fd13ccb5101bb6f07e7560df0d8b1beadc8dacecefd49c7844d298e78991b98dd4650ec7bf0b26716727a7bc437f39a5ccede87c7db6829de68c511abb9d0b4e3644bcf66ad" localRef="blocks_info" location="common.datapartition.BlocksInfo/BlocksInfo.hpe" name="BlocksInfo" package="common.datapartition" exposed="true">
          <visualDescription h="43" w="110" x="448" y="71">
            <color b="255" g="255" r="255"/>
          </visualDescription>
          <unitBounds uRef="blocks">
            <visualDescription h="10" w="10" x="49" y="8"/>
          </unitBounds>
        </port>
        <port hash_component_UID="002400000480000094000000060200000024000052534131000400001100000009b97ce4f3981d78e251ff90894751a2f19e3d7fcafeadee8da1cb93890a7d9ed59b4773f575afc0782c61b877ac17cea1ab4429bfd162c1bdff0b6c7fe9d07f8e9ccdcd219b58671c77cf6cfbada633e18309cb4c2e518fedeaa6aecf435a12dc4a18c8384c15d61dfab5a2056f58c2bcf936823b8d84a8c5cc5e25827a1598" localRef="problem_data" location="common.data.ProblemDefinition/ProblemDefinition.hpe" name="ProblemDefinition" package="common.data" exposed="true">
          <visualDescription h="47" w="102" x="489" y="293">
            <color b="255" g="255" r="255"/>
          </visualDescription>
          <parameter formFieldId="instance_type" varName="I"/>
          <parameter formFieldId="class" varName="C"/>
          <unitBounds uRef="problem">
            <visualDescription h="10" w="10" x="8" y="21"/>
          </unitBounds>
        </port>
        <unitBounds uRef="compute_rhs">
          <visualDescription h="10" w="10" x="13" y="20"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
  </header>
  <componentInfo>
    <innerComponent hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000237f437b205f7bfa00c2d0b40167897c37f84c96a62c077e2832a5360fa8c1c7438dfa969d99bb36a48a7baefcbd50d84ae2e3e71a349dce24c2b0bc473997871be48fdb29d0d48b0928ca968440c6b6663c6740810dab7b664db0e0cfbfe5b21f223402d0d9bd601294898724b6a1da46e78261ef1ee37ac63ca9b2dbdc0d90" localRef="class" location="common.problem_size.Class/Class.hpe" name="Class" package="common.problem_size" exposed="false">
      <visualDescription h="30" w="50" x="432" y="539">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds uRef="class">
        <visualDescription h="10" w="10" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent hash_component_UID="002400000480000094000000060200000024000052534131000400001100000071d38687e0d5d2c316c5b3d07d8aa67134a4623aa2696b4c1af143b9dfb26a795943f7fad788e11c36c09b5001b5422f85c04f6580101d9e27cbf7d06c6cec1d87e42c3a8940336c5c2d63abadb4ac8c1519030710b5b087e1d7e415c91fe07522356c2184e3ea18bf6684dd71bda7b7e5e4411c6b9941ea98fa97bde5ccceb1" localRef="instance" location="common.problem_size.Instance/Instance.hpe" name="Instance" package="common.problem_size" exposed="false">
      <visualDescription h="30" w="50" x="646" y="554">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="class" varName="C"/>
      <unitBounds uRef="instance">
        <visualDescription h="10" w="10" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <supplyParameter cRef="class" varName="C"/>
    <supplyParameter cRef="instance" varName="I"/>
    <interface iRef="IComputeRHSImpl" nArgs="2">
      <slice isRef="blocks">
        <originRef cRef="blocks_info" iRef="IBlocks"/>
        <visualDescription h="10" w="10" x="44" y="25"/>
      </slice>
      <slice isRef="problem">
        <originRef cRef="problem_data" iRef="IProblemDefinition"/>
        <visualDescription h="10" w="10" x="65" y="20"/>
      </slice>
      <protocol xsi:type="component:ActionSkipType" label="hPE.frontend.kinds.activate.model.protocol.HSkipAction@ffa511" repeat="0">
        <visualDescription h="50" w="50" x="75" y="75"/>
      </protocol>
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using common.datapartition.BlocksInfo;&#xA;using common.data.ProblemDefinition;&#xA;using common.ComputeRHS;&#xA;using common.problem_size.Class;&#xA;using common.problem_size.Instance;&#xA;&#xA;namespace impl.common.ComputeRHSImpl { &#xA;&#xA;public abstract class BaseIComputeRHSImpl&lt;I,C>: Computation, BaseIComputeRHS&lt;I,C>&#xA;&#x9;&#x9;where I:IInstance&lt;C>&#xA;&#x9;&#x9;where C:IClass&#xA;{&#xA;&#x9;&#x9;&#xA;protected int ncells;&#xA;&#xA;protected int[,] start;&#xA;protected int[,] end;&#xA;protected int[,] cell_size;&#xA;&#x9;&#x9;&#xA;protected double[,,,,] u, rhs, forcing, us, vs, ws, rho_i, square, qs, speed, ainv;&#x9;&#x9;&#xA;&#x9;&#xA;protected double tx2, ty2, tz2, dssp, dt, xxcon2, xxcon3, xxcon4, xxcon5, dx1tx1, dx2tx1, dx3tx1,&#xA;&#x9;  dx4tx1, dx5tx1, yycon2, yycon3, yycon4, yycon5, dy1ty1, dy2ty1, dy3ty1, dy4ty1, dy5ty1,&#xA;&#x9;  zzcon2, zzcon3, zzcon4, zzcon5, dz1tz1, dz2tz1, dz3tz1, dz4tz1, dz5tz1, c1, c2, c1c2, con43;&#xA;&#x9;&#x9;&#xA;protected IBlocks blocks = null;&#xA;&#xA;public IBlocks Blocks {&#xA;&#x9;get {&#xA;        if (this.blocks == null)&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;    this.blocks = (IBlocks) Services.getPort(&quot;blocks_info&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;start = Blocks.cell_start;&#xA;&#x9;&#x9;&#x9;end = Blocks.cell_end;&#xA;&#x9;&#x9;&#x9;cell_size = Blocks.cell_size;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return this.blocks;&#xA;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;}&#xA;&#xA;protected IProblemDefinition&lt;I,C> problem = null;&#xA;&#xA;public IProblemDefinition&lt;I,C> Problem {&#xA;&#x9;get {&#xA;&#x9;&#x9;if (this.problem == null)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;    this.problem = (IProblemDefinition&lt;I,C>) Services.getPort(&quot;problem_data&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;ncells = Problem.NCells;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;u = Problem.Field_u;&#xA;&#x9;&#x9;&#x9;rhs = Problem.Field_rhs;&#xA;&#x9;&#x9;&#x9;forcing = Problem.Field_forcing;&#xA;&#x9;&#x9;&#x9;us = Problem.Field_us;&#xA;&#x9;&#x9;&#x9;vs = Problem.Field_vs;&#xA;&#x9;&#x9;&#x9;ws = Problem.Field_ws; &#xA;&#x9;&#x9;&#x9;rho_i = Problem.Field_rho;&#xA;&#x9;&#x9;&#x9;square = Problem.Field_square;&#xA;&#x9;&#x9;&#x9;qs = Problem.Field_qs;&#xA;&#x9;&#x9;&#x9;speed = Problem.Field_speed;&#xA;&#x9;&#x9;&#x9;ainv = Problem.Field_ainv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;tx2 = Constants.tx2; &#xA;&#x9;&#x9;&#x9;ty2 = Constants.ty2;&#xA;&#x9;&#x9;&#x9;tz2 = Constants.tz2;&#xA;&#x9;&#x9;&#x9;dssp = Constants.dssp;&#xA;&#x9;&#x9;&#x9;dt = Constants.dt;&#xA;&#x9;&#x9;&#x9;xxcon2 = Constants.xxcon2;&#xA;&#x9;&#x9;&#x9;xxcon3 = Constants.xxcon3;&#xA;&#x9;&#x9;&#x9;xxcon4 = Constants.xxcon4;&#xA;&#x9;&#x9;&#x9;xxcon5 = Constants.xxcon5;&#xA;&#x9;&#x9;&#x9;dx1tx1 = Constants.dx1tx1;&#xA;&#x9;&#x9;&#x9;dx2tx1 = Constants.dx2tx1;&#xA;&#x9;&#x9;&#x9;dx3tx1 = Constants.dx3tx1;&#xA;&#x9;&#x9;    dx4tx1 = Constants.dx4tx1; &#xA;&#x9;&#x9;&#x9;dx5tx1 = Constants.dx5tx1;&#xA;&#x9;&#x9;&#x9;yycon2 = Constants.yycon2;&#xA;&#x9;&#x9;&#x9;yycon3 = Constants.yycon3;&#xA;&#x9;&#x9;&#x9;yycon4 = Constants.yycon4;&#xA;&#x9;&#x9;&#x9;yycon5 = Constants.yycon5;&#xA;&#x9;&#x9;&#x9;dy1ty1 = Constants.dy1ty1;&#xA;&#x9;&#x9;&#x9;dy2ty1 = Constants.dy2ty1;&#xA;&#x9;&#x9;&#x9;dy3ty1 = Constants.dy3ty1;&#xA;&#x9;&#x9;&#x9;dy4ty1 = Constants.dy4ty1;&#xA;&#x9;&#x9;&#x9;dy5ty1 = Constants.dy5ty1;&#xA;&#x9;&#x9;    zzcon2 = Constants.zzcon2;&#xA;&#x9;&#x9;&#x9;zzcon3 = Constants.zzcon3;&#xA;&#x9;&#x9;&#x9;zzcon4 = Constants.zzcon4;&#xA;&#x9;&#x9;&#x9;zzcon5 = Constants.zzcon5;&#xA;&#x9;&#x9;&#x9;dz1tz1 = Constants.dz1tz1;&#xA;&#x9;&#x9;&#x9;dz2tz1 = Constants.dz2tz1;&#xA;&#x9;&#x9;&#x9;dz3tz1 = Constants.dz3tz1;&#xA;&#x9;&#x9;&#x9;dz4tz1 = Constants.dz4tz1;&#xA;&#x9;&#x9;&#x9;dz5tz1 = Constants.dz5tz1;&#xA;&#x9;&#x9;&#x9;c1 = Constants.c1;&#xA;&#x9;&#x9;&#x9;c2 = Constants.c2;&#xA;&#x9;&#x9;&#x9;c1c2 = Constants.c1c2;&#xA;&#x9;&#x9;&#x9;con43 = Constants.con43;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return this.problem;&#xA;&#x9;}&#xA;}&#xA;&#xA;&#xA;abstract public void compute(); &#xA;&#xA;&#xA;}&#xA;&#xA;}&#xA;" fileType="library" name="BaseIComputeRHSImpl.cs" srcType="base" uri="impl.common.ComputeRHSImpl/bin/1.0.0.0/BaseIComputeRHSImpl.dll" versionId="1.0.0.0">
          <dependency>common.datapartition.BlocksInfo/bin/1.0.0.0/IBlocks.dll</dependency>
          <dependency>common.data.ProblemDefinition/bin/1.0.0.0/IProblemDefinition.dll</dependency>
          <dependency>common.ComputeRHS/bin/1.0.0.0/BaseIComputeRHS.dll</dependency>
        </file>
        <file contents="using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using common.ComputeRHS;&#xA;using common.data.ProblemDefinition;&#xA;using common.problem_size.Class;&#xA;using common.problem_size.Instance;&#xA;&#xA;namespace impl.common.ComputeRHSImpl { &#xA;&#xA;public class IComputeRHSImpl&lt;I,C> : BaseIComputeRHSImpl&lt;I,C>, IComputeRHS&lt;I,C>&#xA;&#x9;&#x9;where I:IInstance&lt;C>&#xA;&#x9;&#x9;where C:IClass&#xA;{&#xA;&#xA;&#x9;public IComputeRHSImpl() &#xA;&#x9;{&#xA;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;public override void compute() &#xA;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;    int c, i, j, k, m, ksize, jsize, isize;&#xA;&#x9;    double aux, rho_inv, uijk, up1, um1, vijk, vp1, vm1,&#xA;&#x9;           wijk, wp1, wm1;&#xA;&#x9;&#xA;&#x9;    //---------------------------------------------------------------------&#xA;&#x9;    // loop over all cells owned by this node                           &#xA;&#x9;    //---------------------------------------------------------------------&#xA;&#x9;    for (c = 0; c &lt; ncells; c++)&#xA;&#x9;    {&#xA;&#x9;        ksize = cell_size[c, 2] + 2;&#xA;&#x9;        jsize = cell_size[c, 1] + 2;&#xA;&#x9;        isize = cell_size[c, 0] + 2;&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        //      compute the reciprocal of density, and the kinetic energy, &#xA;&#x9;        //      and the speed of sound. &#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;        for (k = 1; k &lt;= ksize; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = 1; j &lt;= jsize; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = 1; i &lt;= isize; i++)&#xA;&#x9;                {&#xA;&#x9;                    rho_inv = 1.0d / u[c, k, j, i, 0];&#xA;&#x9;                    rho_i[c, k, j, i, 0] = rho_inv;&#xA;&#x9;                    us[c, k, j, i, 0] = u[c, k, j, i, 1] * rho_inv;&#xA;&#x9;                    vs[c, k, j, i, 0] = u[c, k, j, i, 2] * rho_inv;&#xA;&#x9;                    ws[c, k, j, i, 0] = u[c, k, j, i, 3] * rho_inv;&#xA;&#x9;                    square[c, k, j, i, 0] = 0.5d * (&#xA;&#x9;                                  u[c, k, j, i, 1] * u[c, k, j, i, 1] +&#xA;&#x9;                                  u[c, k, j, i, 2] * u[c, k, j, i, 2] +&#xA;&#x9;                                  u[c, k, j, i, 3] * u[c, k, j, i, 3]) * rho_inv;&#xA;&#x9;                    qs[c, k, j, i, 0] = square[c, k, j, i, 0] * rho_inv;&#xA;&#x9;                    //---------------------------------------------------------------------&#xA;&#x9;                    //               (do not need speed and ainx until the lhs computation)&#xA;&#x9;                    //---------------------------------------------------------------------&#xA;&#x9;                    aux = c1c2 * rho_inv * (u[c, k, j, i, 4] - square[c, k, j, i, 0]);&#xA;&#x9;                    aux = Math.Sqrt(aux);&#xA;&#x9;                    speed[c, k, j, i, 0] = aux;&#xA;&#x9;                    ainv[c, k, j, i, 0] = 1.0d / aux;&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        // copy the exact forcing term to the right hand side;  because &#xA;&#x9;        // this forcing term is known, we can store it on the whole grid&#xA;&#x9;        // including the boundary                   &#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;        for (k = 2; k &lt; ksize; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = 2; j &lt; jsize; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = 2; i &lt; isize; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = forcing[c, k, j, i, m];&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        //      compute xi-direction fluxes &#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        //if (timeron) timer.start(t_rhsx);&#xA;&#x9;        for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    uijk = us[c, k, j, i, 0];&#xA;&#x9;                    up1 = us[c, k, j, i + 1, 0];&#xA;&#x9;                    um1 = us[c, k, j, i - 1, 0];&#xA;&#x9;&#xA;&#x9;                    rhs[c, k, j, i, 0] = rhs[c, k, j, i, 0] + dx1tx1 *&#xA;&#x9;                              (u[c, k, j, i + 1, 0] - 2.0d * u[c, k, j, i, 0] +&#xA;&#x9;                               u[c, k, j, i - 1, 0]) -&#xA;&#x9;                              tx2 * (u[c, k, j, i + 1, 1] - u[c, k, j, i - 1, 1]);&#xA;&#x9;&#xA;&#x9;                    rhs[c, k, j, i, 1] = rhs[c, k, j, i, 1] + dx2tx1 *&#xA;&#x9;                              (u[c, k, j, i + 1, 1] - 2.0d * u[c, k, j, i, 1] +&#xA;&#x9;                               u[c, k, j, i - 1, 1]) +&#xA;&#x9;                              xxcon2 * con43 * (up1 - 2.0d * uijk + um1) -&#xA;&#x9;                              tx2 * (u[c, k, j, i + 1, 1] * up1 -&#xA;&#x9;                                     u[c, k, j, i - 1, 1] * um1 +&#xA;&#x9;                                     (u[c, k, j, i + 1, 4] - square[c, k, j, i + 1, 0] -&#xA;&#x9;                                      u[c, k, j, i - 1, 4] + square[c, k, j, i - 1, 0]) *&#xA;&#x9;                                      c2);&#xA;&#x9;&#xA;&#x9;                    rhs[c, k, j, i, 2] = rhs[c, k, j, i, 2] + dx3tx1 *&#xA;&#x9;                              (u[c, k, j, i + 1, 2] - 2.0d * u[c, k, j, i, 2] +&#xA;&#x9;                               u[c, k, j, i - 1, 2]) +&#xA;&#x9;                              xxcon2 * (vs[c, k, j, i + 1, 0] - 2.0d * vs[c, k, j, i, 0] +&#xA;&#x9;                                        vs[c, k, j, i - 1, 0]) -&#xA;&#x9;                              tx2 * (u[c, k, j, i + 1, 2] * up1 -&#xA;&#x9;                                     u[c, k, j, i - 1, 2] * um1);&#xA;&#x9;&#xA;&#x9;                    rhs[c, k, j, i, 3] = rhs[c, k, j, i, 3] + dx4tx1 *&#xA;&#x9;                              (u[c, k, j, i + 1, 3] - 2.0d * u[c, k, j, i, 3] +&#xA;&#x9;                               u[c, k, j, i - 1, 3]) +&#xA;&#x9;                              xxcon2 * (ws[c, k, j, i + 1, 0] - 2.0d * ws[c, k, j, i, 0] +&#xA;&#x9;                                        ws[c, k, j, i - 1, 0]) -&#xA;&#x9;                              tx2 * (u[c, k, j, i + 1, 3] * up1 -&#xA;&#x9;                                     u[c, k, j, i - 1, 3] * um1);&#xA;&#x9;&#xA;&#x9;                    rhs[c, k, j, i, 4] = rhs[c, k, j, i, 4] + dx5tx1 *&#xA;&#x9;                              (u[c, k, j, i + 1, 4] - 2.0d * u[c, k, j, i, 4] +&#xA;&#x9;                               u[c, k, j, i - 1, 4]) +&#xA;&#x9;                              xxcon3 * (qs[c, k, j, i + 1, 0] - 2.0d * qs[c, k, j, i, 0] +&#xA;&#x9;                                        qs[c, k, j, i - 1, 0]) +&#xA;&#x9;                              xxcon4 * (up1 * up1 - 2.0d * uijk * uijk +&#xA;&#x9;                                        um1 * um1) +&#xA;&#x9;                              xxcon5 * (u[c, k, j, i + 1, 4] * rho_i[c, k, j, i + 1, 0] -&#xA;&#x9;                                        2.0d * u[c, k, j, i, 4] * rho_i[c, k, j, i, 0] +&#xA;&#x9;                                        u[c, k, j, i - 1, 4] * rho_i[c, k, j, i - 1, 0]) -&#xA;&#x9;                              tx2 * ((c1 * u[c, k, j, i + 1, 4] -&#xA;&#x9;                                       c2 * square[c, k, j, i + 1, 0]) * up1 -&#xA;&#x9;                                      (c1 * u[c, k, j, i - 1, 4] -&#xA;&#x9;                                       c2 * square[c, k, j, i - 1, 0]) * um1);&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        //      add fourth order xi-direction dissipation               &#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;        if (start[c, 0] > 2)&#xA;&#x9;        {&#xA;&#x9;            i = 3;&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                      (5.0d * u[c, k, j, i, m] - 4.0d * u[c, k, j, i + 1, m] +&#xA;&#x9;                              u[c, k, j, i + 2, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;            i = 4;&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                      (-4.0d * u[c, k, j, i - 1, m] + 6.0d * u[c, k, j, i, m] -&#xA;&#x9;                        4.0d * u[c, k, j, i + 1, m] + u[c, k, j, i + 2, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;        for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = 3 * start[c, 0] - 4; i &lt; isize - 3 * end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                           (u[c, k, j, i - 2, m] - 4.0d * u[c, k, j, i - 1, m] +&#xA;&#x9;                            6.0d * u[c, k, j, i, m] - 4.0d * u[c, k, j, i + 1, m] +&#xA;&#x9;                                u[c, k, j, i + 2, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        if (end[c, 0] > 0)&#xA;&#x9;        {&#xA;&#x9;            i = ksize - 3;&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt;= 4; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (u[c, k, j, i - 2, m] - 4.0d * u[c, k, j, i - 1, m] +&#xA;&#x9;                                6.0d * u[c, k, j, i, m] - 4.0d * u[c, k, j, i + 1, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;            i = ksize - 2;&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt;= 4; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (u[c, k, j, i - 2, m] - 4.0d * u[c, k, j, i - 1, m] +&#xA;&#x9;                                5.0d * u[c, k, j, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        // if (timeron) timer.stop(t_rhsx);&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        //      compute eta-direction fluxes &#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        // if (timeron) timer.start(t_rhsy);&#xA;&#x9;&#xA;&#x9;        for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    vijk = vs[c, k, j, i, 0];&#xA;&#x9;                    vp1 = vs[c, k, j + 1, i, 0];&#xA;&#x9;                    vm1 = vs[c, k, j - 1, i, 0];&#xA;&#x9;                    rhs[c, k, j, i, 0] = rhs[c, k, j, i, 0] + dy1ty1 *&#xA;&#x9;                             (u[c, k, j + 1, i, 0] - 2.0d * u[c, k, j, i, 0] +&#xA;&#x9;                              u[c, k, j - 1, i, 0]) -&#xA;&#x9;                             ty2 * (u[c, k, j + 1, i, 2] - u[c, k, j - 1, i, 2]);&#xA;&#x9;                    rhs[c, k, j, i, 1] = rhs[c, k, j, i, 1] + dy2ty1 *&#xA;&#x9;                             (u[c, k, j + 1, i, 1] - 2.0d * u[c, k, j, i, 1] +&#xA;&#x9;                              u[c, k, j - 1, i, 1]) +&#xA;&#x9;                             yycon2 * (us[c, k, j + 1, i, 0] - 2.0d * us[c, k, j, i, 0] +&#xA;&#x9;                                       us[c, k, j - 1, i, 0]) -&#xA;&#x9;                             ty2 * (u[c, k, j + 1, i, 1] * vp1 -&#xA;&#x9;                                    u[c, k, j - 1, i, 1] * vm1);&#xA;&#x9;                    rhs[c, k, j, i, 2] = rhs[c, k, j, i, 2] + dy3ty1 *&#xA;&#x9;                             (u[c, k, j + 1, i, 2] - 2.0d * u[c, k, j, i, 2] +&#xA;&#x9;                              u[c, k, j - 1, i, 2]) +&#xA;&#x9;                             yycon2 * con43 * (vp1 - 2.0d * vijk + vm1) -&#xA;&#x9;                             ty2 * (u[c, k, j + 1, i, 2] * vp1 -&#xA;&#x9;                                    u[c, k, j - 1, i, 2] * vm1 +&#xA;&#x9;                                    (u[c, k, j + 1, i, 4] - square[c, k, j + 1, i, 0] -&#xA;&#x9;                                     u[c, k, j - 1, i, 4] + square[c, k, j - 1, i, 0])&#xA;&#x9;                                    * c2);&#xA;&#x9;                    rhs[c, k, j, i, 3] = rhs[c, k, j, i, 3] + dy4ty1 *&#xA;&#x9;                             (u[c, k, j + 1, i, 3] - 2.0d * u[c, k, j, i, 3] +&#xA;&#x9;                              u[c, k, j - 1, i, 3]) +&#xA;&#x9;                             yycon2 * (ws[c, k, j + 1, i, 0] - 2.0d * ws[c, k, j, i, 0] +&#xA;&#x9;                                       ws[c, k, j - 1, i, 0]) -&#xA;&#x9;                             ty2 * (u[c, k, j + 1, i, 3] * vp1 -&#xA;&#x9;                                    u[c, k, j - 1, i, 3] * vm1);&#xA;&#x9;                    rhs[c, k, j, i, 4] = rhs[c, k, j, i, 4] + dy5ty1 *&#xA;&#x9;                             (u[c, k, j + 1, i, 4] - 2.0d * u[c, k, j, i, 4] +&#xA;&#x9;                              u[c, k, j - 1, i, 4]) +&#xA;&#x9;                             yycon3 * (qs[c, k, j + 1, i, 0] - 2.0d * qs[c, k, j, i, 0] +&#xA;&#x9;                                       qs[c, k, j - 1, i, 0]) +&#xA;&#x9;                             yycon4 * (vp1 * vp1 - 2.0d * vijk * vijk +&#xA;&#x9;                                       vm1 * vm1) +&#xA;&#x9;                             yycon5 * (u[c, k, j + 1, i, 4] * rho_i[c, k, j + 1, i, 0] -&#xA;&#x9;                                       2.0d * u[c, k, j, i, 4] * rho_i[c, k, j, i, 0] +&#xA;&#x9;                                       u[c, k, j - 1, i, 4] * rho_i[c, k, j - 1, i, 0]) -&#xA;&#x9;                             ty2 * ((c1 * u[c, k, j + 1, i, 4] -&#xA;&#x9;                                     c2 * square[c, k, j + 1, i, 0]) * vp1 -&#xA;&#x9;                                    (c1 * u[c, k, j - 1, i, 4] -&#xA;&#x9;                                     c2 * square[c, k, j - 1, i, 0]) * vm1);&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        //      add fourth order eta-direction dissipation         &#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;        if (start[c, 1] > 2)&#xA;&#x9;        {&#xA;&#x9;            j = 3;&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (5.0d * u[c, k, j, i, m] - 4.0d * u[c, k, j + 1, i, m] +&#xA;&#x9;                                      u[c, k, j + 2, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;            j = 4;&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt;= 4; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (-4.0d * u[c, k, j - 1, i, m] + 6.0d * u[c, k, j, i, m] -&#xA;&#x9;                                4.0d * u[c, k, j + 1, i, m] + u[c, k, j + 2, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = 3 * start[c, 1] - 4; j &lt; jsize - 3 * end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                           (u[c, k, j - 2, i, m] - 4.0d * u[c, k, j - 1, i, m] +&#xA;&#x9;                            6.0d * u[c, k, j, i, m] - 4.0d * u[c, k, j + 1, i, m] +&#xA;&#x9;                                u[c, k, j + 2, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;        if (end[c, 1] > 0)&#xA;&#x9;        {&#xA;&#x9;            j = jsize - 3;&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt;= 4; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (u[c, k, j - 2, i, m] - 4.0d * u[c, k, j - 1, i, m] +&#xA;&#x9;                                6.0d * u[c, k, j, i, m] - 4.0d * u[c, k, j + 1, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;            j = jsize - 2;&#xA;&#x9;            for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt;= 4; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (u[c, k, j - 2, i, m] - 4.0d * u[c, k, j - 1, i, m] +&#xA;&#x9;                                5.0d * u[c, k, j, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;        // if (timeron) timer.stop(t_rhsy);&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        //      compute zeta-direction fluxes &#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        // if (timeron) timer.start(t_rhsz);&#xA;&#x9;        for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    wijk = ws[c, k, j, i, 0];&#xA;&#x9;                    wp1 = ws[c, k + 1, j, i, 0];&#xA;&#x9;                    wm1 = ws[c, k - 1, j, i, 0];&#xA;&#x9;&#xA;&#x9;                    rhs[c, k, j, i, 0] = rhs[c, k, j, i, 0] + dz1tz1 *&#xA;&#x9;                             (u[c, k + 1, j, i, 0] - 2.0d * u[c, k, j, i, 0] +&#xA;&#x9;                              u[c, k - 1, j, i, 0]) -&#xA;&#x9;                             tz2 * (u[c, k + 1, j, i, 3] - u[c, k - 1, j, i, 3]);&#xA;&#x9;                    rhs[c, k, j, i, 1] = rhs[c, k, j, i, 1] + dz2tz1 *&#xA;&#x9;                             (u[c, k + 1, j, i, 1] - 2.0d * u[c, k, j, i, 1] +&#xA;&#x9;                              u[c, k - 1, j, i, 1]) +&#xA;&#x9;                             zzcon2 * (us[c, k + 1, j, i, 0] - 2.0d * us[c, k, j, i, 0] +&#xA;&#x9;                                       us[c, k - 1, j, i, 0]) -&#xA;&#x9;                             tz2 * (u[c, k + 1, j, i, 1] * wp1 -&#xA;&#x9;                                    u[c, k - 1, j, i, 1] * wm1);&#xA;&#x9;                    rhs[c, k, j, i, 2] = rhs[c, k, j, i, 2] + dz3tz1 *&#xA;&#x9;                             (u[c, k + 1, j, i, 2] - 2.0d * u[c, k, j, i, 2] +&#xA;&#x9;                              u[c, k - 1, j, i, 2]) +&#xA;&#x9;                             zzcon2 * (vs[c, k + 1, j, i, 0] - 2.0d * vs[c, k, j, i, 0] +&#xA;&#x9;                                       vs[c, k - 1, j, i, 0]) -&#xA;&#x9;                             tz2 * (u[c, k + 1, j, i, 2] * wp1 -&#xA;&#x9;                                    u[c, k - 1, j, i, 2] * wm1);&#xA;&#x9;                    rhs[c, k, j, i, 3] = rhs[c, k, j, i, 3] + dz4tz1 *&#xA;&#x9;                             (u[c, k + 1, j, i, 3] - 2.0d * u[c, k, j, i, 3] +&#xA;&#x9;                              u[c, k - 1, j, i, 3]) +&#xA;&#x9;                             zzcon2 * con43 * (wp1 - 2.0d * wijk + wm1) -&#xA;&#x9;                             tz2 * (u[c, k + 1, j, i, 3] * wp1 -&#xA;&#x9;                                    u[c, k - 1, j, i, 3] * wm1 +&#xA;&#x9;                                    (u[c, k + 1, j, i, 4] - square[c, k + 1, j, i, 0] -&#xA;&#x9;                                     u[c, k - 1, j, i, 4] + square[c, k - 1, j, i, 0])&#xA;&#x9;                                    * c2);&#xA;&#x9;                    rhs[c, k, j, i, 4] = rhs[c, k, j, i, 4] + dz5tz1 *&#xA;&#x9;                             (u[c, k + 1, j, i, 4] - 2.0d * u[c, k, j, i, 4] +&#xA;&#x9;                              u[c, k - 1, j, i, 4]) +&#xA;&#x9;                             zzcon3 * (qs[c, k + 1, j, i, 0] - 2.0d * qs[c, k, j, i, 0] +&#xA;&#x9;                                       qs[c, k - 1, j, i, 0]) +&#xA;&#x9;                             zzcon4 * (wp1 * wp1 - 2.0d * wijk * wijk +&#xA;&#x9;                                       wm1 * wm1) +&#xA;&#x9;                             zzcon5 * (u[c, k + 1, j, i, 4] * rho_i[c, k + 1, j, i, 0] -&#xA;&#x9;                                       2.0 * u[c, k, j, i, 4] * rho_i[c, k, j, i, 0] +&#xA;&#x9;                                       u[c, k - 1, j, i, 4] * rho_i[c, k - 1, j, i, 0]) -&#xA;&#x9;                             tz2 * ((c1 * u[c, k + 1, j, i, 4] -&#xA;&#x9;                                      c2 * square[c, k + 1, j, i, 0]) * wp1 -&#xA;&#x9;                                     (c1 * u[c, k - 1, j, i, 4] -&#xA;&#x9;                                      c2 * square[c, k - 1, j, i, 0]) * wm1);&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;        //      add fourth order zeta-direction dissipation                &#xA;&#x9;        //---------------------------------------------------------------------&#xA;&#x9;&#xA;&#x9;        if (start[c, 2] > 2)&#xA;&#x9;        {&#xA;&#x9;            k = 3;&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (5.0d * u[c, k, j, i, m] - 4.0d * u[c, k + 1, j, i, m] +&#xA;&#x9;                                      u[c, k + 2, j, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;            k = 4;&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (-4.0d * u[c, k - 1, j, i, m] + 6.0d * u[c, k, j, i, m] -&#xA;&#x9;                                4.0d * u[c, k + 1, j, i, m] + u[c, k + 2, j, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        for (k = 3 * start[c, 2] - 4; k &lt; ksize - 3 * end[c, 2]; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                           (u[c, k - 2, j, i, m] - 4.0d * u[c, k - 1, j, i, m] +&#xA;&#x9;                            6.0d * u[c, k, j, i, m] - 4.0d * u[c, k + 1, j, i, m] +&#xA;&#x9;                                u[c, k + 2, j, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        if (end[c, 2] > 0)&#xA;&#x9;        {&#xA;&#x9;&#xA;&#x9;            k = ksize - 3;&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (u[c, k - 2, j, i, m] - 4.0d * u[c, k - 1, j, i, m] +&#xA;&#x9;                                6.0d * u[c, k, j, i, m] - 4.0d * u[c, k + 1, j, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;&#xA;&#x9;            k = ksize - 2;&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt;= 4; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] - dssp *&#xA;&#x9;                              (u[c, k - 2, j, i, m] - 4.0d * u[c, k - 1, j, i, m] +&#xA;&#x9;                                5.0d * u[c, k, j, i, m]);&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;&#xA;&#x9;        //if (timeron) timer.stop(t_rhsz);&#xA;&#x9;&#xA;&#x9;&#xA;&#x9;        for (k = start[c, 2]; k &lt; ksize - end[c, 2]; k++)&#xA;&#x9;        {&#xA;&#x9;            for (j = start[c, 1]; j &lt; jsize - end[c, 1]; j++)&#xA;&#x9;            {&#xA;&#x9;                for (i = start[c, 0]; i &lt; isize - end[c, 0]; i++)&#xA;&#x9;                {&#xA;&#x9;                    for (m = 0; m &lt; 5; m++)&#xA;&#x9;                    {&#xA;&#x9;                        rhs[c, k, j, i, m] = rhs[c, k, j, i, m] * dt;&#xA;&#x9;                    }&#xA;&#x9;                }&#xA;&#x9;            }&#xA;&#x9;        }&#xA;&#x9;    }&#xA;&#x9;&#xA;&#x9;} // end activate method &#xA;&#xA;}&#xA;&#xA;}&#xA;" fileType="library" name="IComputeRHSImpl.cs" srcType="user" uri="impl.common.ComputeRHSImpl/bin/1.0.0.0/IComputeRHSImpl.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/impl.common.ComputeRHSImpl/bin/1.0.0.0/BaseIComputeRHSImpl.dll</dependency>
          <dependency>common.ComputeRHS/bin/1.0.0.0/IComputeRHS.dll</dependency>
        </file>
      </sources>
      <visualDescription h="40" w="137" x="131" y="118">
        <color b="128" g="128" r="64"/>
      </visualDescription>
      <port name="blocks">
        <visualDescription h="10" w="10" x="0" y="0"/>
        <slice pRef="blocks" sRef="blocks"/>
      </port>
      <port name="problem">
        <visualDescription h="10" w="10" x="0" y="0"/>
        <slice pRef="problem" sRef="problem"/>
      </port>
      <parameter iname="IInstance" order="0" parid="instance_type" uname="instance" varid="I"/>
      <parameter iname="IClass" order="1" parid="class" uname="class" varid="C"/>
    </interface>
    <unit iRef="IComputeRHSImpl" private="false" uRef="compute_rhs" visibleInterface="true">
      <super cRef="base" uRef="compute_rhs"/>
      <slices cRef="blocks_info" replica="0" uRef="blocks" sliceName="blocks" transitive="false">
        <visualDescription h="10" w="10" x="44" y="25"/>
      </slices>
      <slices cRef="problem_data" replica="0" uRef="problem" sliceName="problem" transitive="false">
        <visualDescription h="10" w="10" x="65" y="20"/>
      </slices>
      <visualDescription h="40" w="80" x="63" y="213"/>
    </unit>
    <enumerator cardinality="-1" fromSplit="false" ref="hPE.frontend.base.model.HReplicator@1b2533d1295099559883" varId="n">
      <originRef>base</originRef>
      <originRef>problem_data</originRef>
      <originRef>speed</originRef>
      <links xsi:type="component:EnumerableUnitType" ref="compute_rhs"/>
      <visualDescription h="32" w="36" x="63" y="349"/>
    </enumerator>
  </componentInfo>
</component:component>